\section{Satellite galaxies around a massive central - part 2}

In this section we look at question 1 of the third hand-in. 
I have mostly copy-pasted my functions from the tutorials, where I worked together with my sister,
Evelyn van der Kamp (s2138085), so some of our functions are quite similar.

\lstinputlisting{NURHW3LizQ1.py}

\subsection{Question 1a}

In this section I took my function from the previous hand-in for $4 \pi n(x) x^2$, now with A given.
I also made a function which returns $-4 \pi n(x) x^2$, because finding the minimum of that function is the same as finding the maximum of the positive function.
I imported my golden section search algorithm and called it to search for the minimum between 0 and $x_{max} = 5$, with as my first guess for the maximum $x=1$.
I took my target accuracy to be $10^{-20}$ and the maximum iterations to be 100.
I found the following maximum and function value at the maximum:

\lstinputlisting{Maximumoutput.txt}

Here, the first value shows the radius at the maximum, and the second value is $N(x)$ at the maximum.


\subsection{Question 1b}

Here we want to generate 3D satellite positions such that they statistically follow the satellite profile $n(x)$.
Here I assumed that $N(x)$d$x = 4\pi x^2 n(x)$d$x$, such that the integral from 0 to $x_{max}$ over $N(x)$d$x/<N_{sat}> = 1$, just like a probability distribution should do.
For this I created a function that uses rejection sampling to sample the distribution.
This function calls a random number generated which I created during one of the tutorial classes, combining a 64-bit XOR method with an LCG.
The random number generator can return random numbers between 0 and 1 as long as the size you give it is large enough (only requesting 1 random number between 0 and 1 will always result in 1, since I divide by the largest number in the array to get numbers between 0 and 1, which also means that 1 is always present in the array of random numbers somewhere).
I create an array of 100 random numbers between 0 and 1, each time with a different seed, then take the first number from that array and transform it into a number between $10^{-4}$ and $x_{max}$, called $x$, then take the second number from that array and transform it into a number $y$ between 0 and the max of $p(x)$d$x$.
If $y \geq p(x)$ then we reject it, otherwise we accept it into the sample.
This rejection sampling algorithm is not the fastest one and could be improved if we could invert the probability function and calculate its primitive and then applying the transformation method.

I sampled $10^4$ satellite galaxies and then created some arrays to plot a log-log plot of $N(x)$ and the histogram, with 20 logarithmically spaced bins.
For the histogram I used \texttt{plt.hist}, and by taking \texttt{density = True} we divide the bins by their width and divide by the number of counts.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.9\linewidth]{Probabilityplot.png}
  \caption{A plot of $x$ versus $p(x)$d$x = N(x)$d$x/<N_{sat}>$, showing $N(x)$ as the black curve and my sampled distribution as a histogram. These both agree quite well with each other.}
  \label{fig:px}
\end{figure}

The plot generated can bee seen in Figure \ref{fig:px}, where it can be seen that the histogram and the curve agree well with each other.


\subsection{Question 1c}

In this question it was asked to select 100 random satellite galaxies from the sample in (b) in a way that is guaranteed to select every galaxy with equal probability, not draw the same galaxy twice and not reject any draw.
For this question I imported my Quicksort function created in the tutorials, which consists of two separate functions, one of which sorts the partial arrays and is called by the main function.
I also imported my swapping function from tutorial 3, which can swap two given entries in an array.
The Quicksort function has the ability to return the array of indices belonging to the sorted array, which I used here to shuffle the array of sampled positions.

I first created an array of $10^4$ uniform random numbers with my random number generator, then I sorted this array with my Quicksort function and returned the indices to get a shuffled array of $10^4$ indices, which I apply to the sampled positions to shuffle the array.
Then I took the first 100 positions from that shuffled array to get 100 random satellite galaxies, without repeats, without rejections, having selected them with equal probability.

Afterwards, I sorted those 100 positions with my Quicksort function from smallest to largest radius.
The number of galaxies within a radius is now equal to 0 at $x = 10^{-4}$ and 100 at $x_{max}$, and it is equal to the one plus the index of the sorted array at the radius that corresponds to the index.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.9\linewidth]{Numberplot.png}
  \caption{A plot of $x$ versus the number of galaxies within that radius. It steadily goes up until it goes flat around $x = 0.8$.}
  \label{fig:Nr}
\end{figure}

The plot generated can bee seen in Figure \ref{fig:Nr}, where it can be seen that the histogram and the curve agree well with each other.


\subsection{Question 1d}

In this part of the question it was asked to numerically calculate d$n(x)/$d$x$ at $x = 1$.
I imported two functions from the tutorials, one which calculates the derivative of a function using the central difference formula, with stepsize $h$, and one which calls this central difference function and uses Ridder\'s method to calculate the numerical derivative of a function, similar to Romberg integration, by iterating over different solutions. 
The analytical derivative here is only used to calculate the error and to make sure that it stays below the target error.
Ridder\'s method is the most accurate, because it takes solutions of different stepsizes and combines them to get to a more accurate result.

I also made a function that returns the analytical derivative d$n(x)/$d$x = A <N_{sat}> (x^{a-4}/b^{a-3})*\exp(-(x/b)^c)  (a-3-c (x/b)^c)$.
I took an initial stepsize $h = 0.1$ and iterated with a target error of $10^{-10}$, meaning that the difference between the analytical derivative and the calculated solution needs to go below the target error before the function terminates, or that the max number of iterations has been reached, which I picked to be 100.

The result is as follows:

\lstinputlisting{Derivativeoutput.txt}

Here the first number shows the result of the analytical derivative, the second number shows the result of the numerical differentiation, and the third number shows the absolute difference between the two.

